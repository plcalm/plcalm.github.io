<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github</title>
      <link href="/2021/11/22/GitHub-github/"/>
      <url>/2021/11/22/GitHub-github/</url>
      
        <content type="html"><![CDATA[<h4 id="1-什么是github"><a href="#1-什么是github" class="headerlink" title="1. 什么是github?"></a>1. 什么是github?</h4><p>Github是用于版本控制和协作开发的代码托管平台</p><h4 id="2-为什么要用github"><a href="#2-为什么要用github" class="headerlink" title="2. 为什么要用github?"></a>2. 为什么要用github?</h4><p>Github是最流行的开源项目托管平台，可以在其中找到优秀的项目学习以有助于自己的研究与开发工作</p><h4 id="3-Git是什么？"><a href="#3-Git是什么？" class="headerlink" title="3. Git是什么？"></a>3. Git是什么？</h4><p>Git是一个版本控制系统，使用Git的项目可以更好的进行版本管理，便于对项目做开发、修改、还原和发布等</p><h4 id="4-Github基本概念"><a href="#4-Github基本概念" class="headerlink" title="4. Github基本概念"></a>4. Github基本概念</h4><h5 id="（1）仓库-Repository"><a href="#（1）仓库-Repository" class="headerlink" title="（1）仓库(Repository)"></a>（1）仓库(Repository)</h5><p>仓库是用来管理和存放一个单独的项目，一个Repo通常需要一个READMD文件</p><h5 id="（2）本地-local-与远程-remote"><a href="#（2）本地-local-与远程-remote" class="headerlink" title="（2）本地(local)与远程(remote)"></a>（2）本地(local)与远程(remote)</h5><p>本地项目通过 <code>push</code> 到 github上自己的账户中，可以通过 <code>pull</code> 可以对本地仓库进行更新相对于自己的github</p><p>本地项目于远程项目处于相对独立的状态，通过 <code>pull</code> 与 <code>push</code> 命令可以实现代码的更新同步</p><h5 id="（3）分支-Branch"><a href="#（3）分支-Branch" class="headerlink" title="（3）分支(Branch)"></a>（3）分支(Branch)</h5><p>分支可以让我们在项目中处理多个版本，一般默认分支是 <code>main</code> (有的默认分支是master)，通过创建分支来修改项目，然后再提交并入 <code>main</code> 分支。</p><p>分支的重要作用是协同开发，多开发人员就是通过创建分支进行代码的修复开发等然后合并(<code>merge</code>) 到 <code>main</code> 分支上</p><p>当基于 <code>main</code> 分支创建新分支，可以理解为是基于当前 <code>main</code> 分支的一个拷贝，之后如果 <code>main</code> 分支有了新的更改，可以通过 <code>pull</code> 对当前分支进行更新</p><h5 id="（4）提交-Commit"><a href="#（4）提交-Commit" class="headerlink" title="（4）提交(Commit)"></a>（4）提交(Commit)</h5><p>首先需要将工作区文件添加到暂存区 <code>git add hello.c</code></p><p>可以通过 <code>git status</code> 来查看文件状态（确定文件当前所处Git工作区域-工作区、暂存区、仓库），确定哪些文件需要添加，添加到暂存区之后再提交</p><p>然后将暂存区文件提交到仓库 <code>git commit -m &quot;提交描述&quot;</code></p><p>删除工作区文件：<code>git rm -f a.txt</code></p><h5 id="（5）拉取请求-Pull-Request"><a href="#（5）拉取请求-Pull-Request" class="headerlink" title="（5）拉取请求(Pull Request)"></a>（5）拉取请求(Pull Request)</h5><p>拉取请求(Pull Request) 又称作 <code>PR</code>，当提交一个PR，表明将自己对项目的修改并入到别人项目中的某一个分支里去，经过对方项目相关人员进行审核，然后完成并入操作(merge)</p><h5 id="（6）Fork"><a href="#（6）Fork" class="headerlink" title="（6）Fork"></a>（6）Fork</h5><p><code>Fork</code> 通常是指拷贝一个repo，这个repo可以作为你要修改、贡献该项目的起点，或者作为自己项目的一个组件</p><p>如果发现别人项目的bug，可以先fork，然后再拉取请求(PR)</p><h5 id="（7）克隆-Clone"><a href="#（7）克隆-Clone" class="headerlink" title="（7）克隆(Clone)"></a>（7）克隆(Clone)</h5><p>克隆操作指的是将远程项目拷贝到本地进行使用或者修改，使用 <code>clone</code> 命令</p><p>当远程项目有更新时候，直接使用 <code>pull</code> 可以将远程 <code>repo</code> 的更新内容拉取到本地项目中</p><p>如果是自己创建的远程仓库，在本地修改并提交后可以通过 <code>push</code> 命令将这些更新，上传到远程 <code>repo</code> 中</p><pre class=" language-shell"><code class="language-shell">git clone ...git pull ...git push  ...</code></pre><blockquote><p>注：如果Clone的是别人的项目，通常只有pull权限，而不能push，如果想要修改别人的项目可以通过 <code>fork+clone+push+PR</code> 的方式</p></blockquote><h5 id="（8）星标-Star"><a href="#（8）星标-Star" class="headerlink" title="（8）星标(Star)"></a>（8）星标(Star)</h5><p>受欢迎程度</p><h4 id="5-如何使用Github上的开源项目"><a href="#5-如何使用Github上的开源项目" class="headerlink" title="5. 如何使用Github上的开源项目"></a>5. 如何使用Github上的开源项目</h4><h5 id="（1）Case1-我希望使用某个项目"><a href="#（1）Case1-我希望使用某个项目" class="headerlink" title="（1）Case1. 我希望使用某个项目"></a>（1）Case1. 我希望使用某个项目</h5><ol><li>将项目 <code>git clone</code> 到本地</li><li>使用项目</li><li>如果远程有更新，使用 <code>git pull</code> 拉取更新</li></ol><h5 id="（2）Case2-我希望修改或者为某个项目增加功能"><a href="#（2）Case2-我希望修改或者为某个项目增加功能" class="headerlink" title="（2）Case2. 我希望修改或者为某个项目增加功能"></a>（2）Case2. 我希望修改或者为某个项目增加功能</h5><ol><li>将远程 Repo <code>fork</code> 到自己的github中</li><li>将此仓库 <code>git clone</code> 到本地</li><li>进行修改增加</li><li>将修改后的代码 <code>commit</code> 到仓库</li><li><code>git push</code> 推送到自己的远程仓库</li><li>通过 <code>Pull Request</code> 拉取请求</li><li>对方项目相关人员审核无误之后就可以并入Repo</li></ol><h4 id="6-Github使用示例"><a href="#6-Github使用示例" class="headerlink" title="6. Github使用示例"></a>6. Github使用示例</h4><ol><li><p>下载并开始使用PaddleViT项目</p><ol><li><p>克隆项目到本地</p><pre class=" language-shell"><code class="language-shell">git clone https://github.com/BR-IDL/PaddleViT.git</code></pre></li><li><p>安装依赖</p></li><li><p>使用</p></li></ol></li><li><p>参与PaddleViT项目的开发:</p><ol><li><p>Fork</p></li><li><p>Clone</p><pre class=" language-shell"><code class="language-shell">git clone https://github.com/YOUR_ACCOUNT/PaddleViT.git</code></pre></li><li><p>进入项目文件夹创建新 <code>branch</code>，默认会基于 <code>develop</code> 分支创建新分支</p><pre class=" language-shell"><code class="language-shell">git checkout -b YOUR_BRANCH_NAME</code></pre><p> <code>YOUR_BRANCH_NAME</code> 是分支名</p></li><li><p>完成开发</p></li><li><p>完成 <code>commit</code></p><pre class=" language-shell"><code class="language-shell">git add .  # 将当前文件夹下的所有文件都提交到暂存区git commit -m "YOUR_BRANCH_NAME" #message简洁明了, 这一步将暂存区文件全部提交到本地仓库</code></pre></li><li><p>将代码 <code>push</code> 到远程</p><pre class=" language-shell"><code class="language-shell">git push origin YOUR_BRANCH_NAME # origin通常是指向本地代码在github上的远程版本</code></pre></li><li><p>创建 <code>PR</code> </p><ol><li>在GitHub项目页面，点击 <code>Pull Request</code> Tab</li><li>点击 <code>New pull request</code> ，选择 Forked Repo的分支和目标推送到项目的分支</li><li>点击 <code>Create pull request</code> </li></ol></li></ol></li></ol><p><a href="https://aistudio.baidu.com/aistudio/projectdetail/2884515">转载</a></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vision Transformer</title>
      <link href="/2021/11/19/DeepLearning-CV-Vision-Transformer/"/>
      <url>/2021/11/19/DeepLearning-CV-Vision-Transformer/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/11/19/DeepLearning-CV-Vision-Transformer/all_pipline.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 论文解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cv-vit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试图片</title>
      <link href="/2021/11/19/DeepLearning-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-test/"/>
      <url>/2021/11/19/DeepLearning-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-test/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/11/19/DeepLearning-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95-test/test.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker-天池</title>
      <link href="/2021/11/16/Docker-docker/"/>
      <url>/2021/11/16/Docker-docker/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Linux安装"><a href="#1-Linux安装" class="headerlink" title="1. Linux安装"></a>1. Linux安装</h4><pre class=" language-shell"><code class="language-shell">sudo curl -sS https://get.docker.com/ | sh</code></pre><p>测试</p><pre class=" language-shell"><code class="language-shell">sudo docker run hello-world</code></pre><p>测试运行</p><pre class=" language-shell"><code class="language-shell">docker run -it ubuntu bash</code></pre><p>若有Gpu:</p><pre class=" language-shell"><code class="language-shell">distribution=$(. /etc/os-release;echo $ID$VERSION_ID)curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get update && sudo apt-get install -y nvidia-container-toolkitsudo systemctl restart docker</code></pre><p>拉取一个pytorch镜像</p><pre class=" language-shell"><code class="language-shell">sudo docker pull registry.cn-shanghai.aliyuncs.com/tcc-public/pytorch:1.4-cuda10.1-py3</code></pre><p>运行</p><pre class=" language-shell"><code class="language-shell">sudo docker run --gpus all -it registry.cn-shanghai.aliyuncs.com/tcc-public/pytorch:1.4-cuda10.1-py3 /bin/bash# 加载gpu，不然容器中加载不了gpu，nvidia-smi命令也找不到， all可以改成0,1,2...</code></pre><h4 id="2-创建镜像仓库账号"><a href="#2-创建镜像仓库账号" class="headerlink" title="2. 创建镜像仓库账号"></a>2. 创建镜像仓库账号</h4><p>打开阿里云容器服务地址：<a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com</a></p><p>注册个人版</p><p><img src="/2021/11/16/Docker-docker/tianchi_1.png"></p><p>第一步切换标签页到命名空间，创建地址唯一的命名空间</p><p><img src="/2021/11/16/Docker-docker/tianchi_2.png"></p><p>根据大赛要求选择对应的地域，其他按需求填写</p><p><img src="/2021/11/16/Docker-docker/tianchi_3.png"></p><p>下一步，选择本地仓库</p><p><img src="/2021/11/16/Docker-docker/tianchi_4.png"></p><p>点击管理可查看详情</p><p><img src="/2021/11/16/Docker-docker/tianchi_6.png"></p><p>详情页如下，有基本的操作命令，仓库地址一般使用公网地址即可。</p><p><img src="/2021/11/16/Docker-docker/tianchi_7.png"></p><p>按照页面的指令在本地完成登录：</p><pre class=" language-shell"><code class="language-shell"># 切换到超级管理员用户，否则环境变量设置是当前用户，会找不到环境变量export DOCKER_REGISTRY=you_registry_url<docker registry url> # 到命名空间即可（命名空间/仓库名）docker login $DOCKER_REGISTRY --username [...] --password [...]</code></pre><p><img src="/2021/11/16/Docker-docker/tianchi_8.png"></p><p>登录成功就可以push了</p><pre class=" language-shell"><code class="language-shell">docker tag hello-world:latest registry.cn-hangzhou.aliyuncs.com/命名空间/test:0.1  # 先tag一下docker push registry.cn-hangzhou.aliyuncs.com/命名空间/test:0.1            # 再推送</code></pre><p>结果成功：</p><p><img src="/2021/11/16/Docker-docker/tianchi_9.png"></p><h4 id="3-构建docker镜像，push到云端"><a href="#3-构建docker镜像，push到云端" class="headerlink" title="3. 构建docker镜像，push到云端"></a>3. 构建docker镜像，push到云端</h4><pre class=" language-shell"><code class="language-shell"># 下载脚本wget "http://tianchi-media.oss-cn-beijing.aliyuncs.com/docker-tool/tianchi_docker.zip"# 解压unzip tianchi_docker.zipcd tianchi_dockersh docker_build.sh 0.1  # (0.1为自己指定的版本号)</code></pre><p>报错：</p><p><img src="/2021/11/16/Docker-docker/tianchi_10.png"></p><p>修改Dockerfile</p><p><img src="/2021/11/16/Docker-docker/tianchi_11.png"></p><p>修改后</p><p><img src="/2021/11/16/Docker-docker/tianchi_12.png"></p><p>push结束后</p><p>大赛提交镜像</p><p><img src="/2021/11/16/Docker-docker/tianchi_13.png"></p><p>具体参考文后链接。</p><p>利用dockerfile</p><pre class=" language-shell"><code class="language-shell"># 先移除build_docker.shdocker build -t registry.cn-hangzhou.aliyuncs.com/命名空间/tianchi-submit:0.2 .   # 最后一个点是当前路径docker push registry.cn-hangzhou.aliyuncs.com/命名空间/tianchi-submit:0.2 # 上传结束提交即可</code></pre><p>为了解决每次编译都要pip下载的问题，可以修改镜像，然后commit，修改dockerfile即可</p><p>模拟磁盘映射</p><pre class=" language-shell"><code class="language-shell">docker run -it -v /storage:/tcdata registry.cn-shanghai.aliyuncs.com/tcc-public/pytorch:1.4-cuda10.1-py3 # -v 本地路径:镜像路径</code></pre><p>将镜像保存</p><pre class=" language-shell"><code class="language-shell">docker save registry.cn-hangzhou.aliyuncs.com/命名空间/tianchi-submit:0.2 -o 123# 加载docker load -i 123</code></pre><p>参考链接：<a href="https://tianchi.aliyun.com/forum/postDetail?postId=76615">天池大赛从0开始docker提交</a>  <a href="https://tianchi.aliyun.com/specials/activity/promotion/aicampdocker?spm=5176.12281976.0.0.c4ba77c7oCJBRy">参考视频1</a> <a href="https://tianchi.aliyun.com/course/351/4131">参考视频2</a> <a href="https://tianchi.aliyun.com/forum/postDetail?spm=5176.12281915.0.0.570d2cb9SnfgZK&postId=67720">天池基础镜像</a></p><ol><li><p><a href="https://tianchi.aliyun.com/competition/entrance/531863/information">零基础入门Docker-cuda练习场</a></p></li><li><p><a href="https://tianchi.aliyun.com/competition/entrance/231759/information">入门Docker练习场</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tianchi_docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux打卡学习</title>
      <link href="/2021/11/16/Linux-linux/"/>
      <url>/2021/11/16/Linux-linux/</url>
      
        <content type="html"><![CDATA[<h3 id="1-登录服务器"><a href="#1-登录服务器" class="headerlink" title="1. 登录服务器"></a>1. 登录服务器</h3><img src="/2021/11/16/Linux-linux/login.png" style="zoom:80%;"><h3 id="2-在目录下创建文件夹、删除文件夹"><a href="#2-在目录下创建文件夹、删除文件夹" class="headerlink" title="2. 在目录下创建文件夹、删除文件夹"></a>2. 在目录下创建文件夹、删除文件夹</h3><h4 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h4><p><strong>系统启动必须</strong></p><p><strong><code>/etc</code></strong> 系统管理所需的配置文件和子目录</p><p><code>/boot</code> 存放启动Linux时的一些核心文件，包括链接文件以及镜像文件</p><p><code>/lib</code> 系统最基本的动态链接共享库，作用类似 Windows 中的DLL文件</p><p><code>/sys</code> Linux2.6内核的一个很大的变化，安装其内核新出现的一个文件系统sysfs</p><p><strong>指令集合</strong></p><p><strong><code>/bin</code></strong> 存放经常使用的命令，<strong>系统用户</strong></p><p><strong><code>/sbin</code></strong> 超级用户的二进制文件缩写，存放<strong>系统管理员</strong>的系统管理程序</p><p><strong>外部文件管理</strong></p><p><code>/dev</code> Linux的外部设备，Linux中访问设备和访问文件是一样的</p><p><code>/media</code> Linux系统自动识别设备放在这个目录下</p><p><code>/mnt</code> 系统提供该目录为了让用户临时挂载别的文件系统，可以将光驱挂载在这个文件夹下</p><p><strong>临时文件</strong></p><p><code>/run</code> 临时文件系统，存储系统重启以来的信息</p><p><code>/lost+found</code> 当非法关机后，存放一些文件</p><p><code>/tmp</code> 临时文件</p><p><strong>账号</strong></p><p><code>/root</code> 该目录是系统管理员的主目录</p><p><code>/home</code> 用户主目录</p><p><code>/usr</code> 共享资源的缩写，用户应用程序和文件存放处，类似于windows下的 program files目录</p><p><strong><code>/usr/bin</code></strong> <strong>系统用户</strong>所使用的应用程序</p><p><strong><code>/usr/sbin</code></strong> 超级用户使用的比较高级的<strong>管理程序和系统守护程序</strong></p><p><code>/usr/src</code> 内核源代码默认的放置目录</p><p><strong>运行过程中要用</strong></p><p><code>/var</code> 经常需要修改的目录在这个目录下，包括各种日志文件</p><p><code>/proc</code> 一种伪文件系统，存储当前内核运行状态的一系列特殊文件，虚拟目录是内存的映射，可以访问这个目录获取系统信息</p><p><strong>扩展使用</strong></p><p><code>/opt</code> 给主机额外安装软件所摆放的目录</p><p><code>/srv</code> 服务启动之后需要提取的数据</p><p><code>/selinux</code> 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似Windows的防火墙</p><h4 id="Linux文件于目录管理"><a href="#Linux文件于目录管理" class="headerlink" title="Linux文件于目录管理"></a>Linux文件于目录管理</h4><p>Linux的目录结构为树状结构，最顶级的目录为根目录 <code>/</code> </p><p>其他目录通过挂载将它们添加到树种，也可以解除挂载</p><p>绝对路径 <code>/</code> 开始， 相对路径 <code>./</code> 、<code>../</code> 分别表示当前目录和上级目录</p><p><strong>处理目录常用命令</strong></p><p><code>ls</code> 列出目录和文件名</p><p>​    <code>-a</code> 全部文件</p><p>​    <code>-d</code> 仅列出目录本身</p><p>​    <code>-l</code> 长数据串列出，包含文件属性和权限等</p><p><code>cd</code> 切换目录</p><p><code>pwd</code> 显示目前的目录</p><p>​    <code>-P</code> 显示出确实的路径，而不是link路径</p><p><code>mkdir</code> 创建一个目录</p><p>​    <code>-m</code> 配置文件的权限</p><p>​    <code>-p</code> 递归创建目录</p><p><code>rmdir</code> 删除一个空的目录</p><p>​    <code>-p</code> 递归删除，详细目录</p><p><code>cp</code> <code>[--adfilprsu]</code>复制文件或目录， 源+目标</p><p>​    <code>-r</code> 递归持续复制</p><p>​    <code>-s</code> 复制成符号链接</p><p>​    <code>-i</code> 若目标存在，则会询问</p><p><code>rm</code>  <code>-fir</code> 删除文件或目录</p><p>​    <code>-r</code> 递归删除</p><p>​    <code>-f</code> 强制</p><p>​    <code>-i</code> 询问</p><p><code>mv</code>  <code>[-fiu]</code> 移动文件与目录，或者修改文件与目录的名称</p><p>​    <code>-f</code> 强制</p><p>​    <code>-i</code> 询问</p><p>​    <code>-u</code> 若目标已经存在，源比较新才会升级</p><p><strong>Linux文件内容查看</strong></p><p><code>cat</code> <code>[-AbEnTv]</code> 从第一行开始显示文件内容</p><p><code>tac</code> 从最后一行开始显示</p><p><code>nl</code> <code>[-bnw]</code> 显示的时候带上行号</p><p><code>more</code> 一页一页显示文件内容</p><p><code>less</code> 和 <code>more</code> 类似，但是能向前翻页</p><p><code>head</code> <code>[-n]</code> 只看几行</p><p><code>tail</code> <code>[-n]</code> 只看尾部几行</p><p>可以使用 <code>man [命令]</code> 查看命令详细用法</p><p>硬链接和软链接</p><p><code>ln f1 f2</code> 创建硬链接</p><p><code>ln -s f1 f3</code> 创建软链接</p><p><code>ls -li</code> <code>-i</code> 显示文件的inode节点信息</p><pre class=" language-shell"><code class="language-shell">cd /homecd coggle# 创建文件夹 plcalmmkdir plcalmcd plcalm# 创建文件夹 cogglemkdir cogglecd coggle# 创建文件 test.txttouch test.txt# 删除文件 test.txtrm test.txtcd ..# 删除文件夹rm -r coggle/cd ..# 删除文件夹rm -r plcalm/</code></pre><h3 id="3-在目录下下载文件、阅读文件"><a href="#3-在目录下下载文件、阅读文件" class="headerlink" title="3. 在目录下下载文件、阅读文件"></a>3. 在目录下下载文件、阅读文件</h3><p>wget教程：<a href="https://www.cnblogs.com/pretty-ru/p/10936023.html">教程</a></p><p>阅读文件教程：<a href="https://www.cnblogs.com/jixp/p/10833801.html">教程</a></p><pre class=" language-shell"><code class="language-shell"># 在/home/coggle目录下，新建plcalm文件夹cd /home/cogglemkdir plcalm# 在plcalm文件夹中新建coggle文件夹cd plcalm# 下载文件wget https://mirror.coggle.club/dataset/affairs.txt# 使用head、cat、tail 文件查看文件head -n 10 affairs.txttail -n 10 affairs.txtcat affairs.txt# 使用ipython进入python环境ipython>>>import pandas as pd>>>data = pd.read_table("affairs.txt", sep=",")>>>data[:5]            # 打印前5行</code></pre><p><strong>利用pandas读取和写入文件</strong></p><p>读取.csv文件：pd.read_csv(path,[index_col=列的下标]), 路径上可以加上r，防止路径产生歧义</p><p>读取.txt文件：pd.read_table(path, sep=”,”), 以’,’为分隔符号读入</p><p>读取.excel文件：pd.read_excel(path)</p><p>写入.csv文件：变量名.to_csv(文件路径+文件名, index=False)</p><p>写入.txt文件：变量名.to_csv(文件路径+名字，sep=’\t’, index=False)</p><p>写入.excel文件：变量名.to_excel(文件名+名字, index=False)</p><h3 id="4-在目录下使用vi或vim编辑文件"><a href="#4-在目录下使用vi或vim编辑文件" class="headerlink" title="4. 在目录下使用vi或vim编辑文件"></a>4. 在目录下使用vi或vim编辑文件</h3><p>Nano教程：<a href="https://blog.csdn.net/junxieshiguan/article/details/84104912">教程</a></p><p><code>Ctrl+G</code> 相当于指令说明书</p><p><code>Ctrl+X</code> 离开nano软件</p><p><code>Ctrl+C</code> 显示光标处行列信息</p><p>Vim教程：<a href="https://www.runoob.com/linux/linux-vim.html">教程</a></p><p>三种模式：命令模式、输入模式、底线命令模式</p><p>刚启动便是命令模式，输入 <code>i</code> 进入输入模式，<code>x</code> 删除光标所在字符，<code>:</code> 切换到底线命令模式</p><p>输入模式，正常输入即可，<code>ESC</code> 退出输入模式，<code>insert</code> 切换光标为输入/替换模式，光标变成竖线/下划线</p><p>底线命令模式，在命令模式，<code>:</code> 进入底线命令模式，<code>q</code> 退出程序，<code>w</code> 保存程序，<code>!</code> 强制退出</p><h3 id="5-在目录下创建py文件，并运行"><a href="#5-在目录下创建py文件，并运行" class="headerlink" title="5. 在目录下创建py文件，并运行"></a>5. 在目录下创建py文件，并运行</h3><p>os模块：<a href="https://www.runoob.com/python/os-file-methods.html">教程</a></p><p>sys模块：<a href="https://www.runoob.com/python3/python3-module.html">教程</a></p><pre class=" language-shell"><code class="language-shell"># 新建文件test5.pycd /home/coggletouch test5.pyvim test5.py"""程序：#!/usr/bin/env python3import sysprint('命令参数如下：')for i in sys.argv:    print(i)"""python3 test5.py</code></pre><p>结果：</p><img src="/2021/11/16/Linux-linux/1.png"><pre class=" language-shell"><code class="language-shell"># 打印/usr/bin/下的所有m开头的文件touch test_os.pyvim test_os.py"""程序#!/usr/bin/env python3import osfile_data = os.listdir("/usr/bin")for i in file_data:    file = os.path.split(i)    if file[-1][0] == "m":        print(file[-1])"""</code></pre><p>结果：</p><img src="/2021/11/16/Linux-linux/2.png" style="zoom:80%;"><h3 id="6-在目录下创建py目录，并进行import导入"><a href="#6-在目录下创建py目录，并进行import导入" class="headerlink" title="6. 在目录下创建py目录，并进行import导入"></a>6. 在目录下创建py目录，并进行import导入</h3><p>学习python模块化，<a href="https://www.runoob.com/python3/python3-module.html">教程</a></p><pre class=" language-shell"><code class="language-shell"># /home/coggle/plcalm# 新建文件夹affairsmkdir affairscd affairs# 新建affairs.py"""程序：#!/usr/bin/env python3import pandas as pddef read_data(path):    data = pd.read_csv(path,sep=',')    return data"""# /home/coggle/plcalm# 新建test6.py"""程序：#!/usr/bin/env python3import sysfrom affairs.affairs import read_datarow = sys.argv[1]data = read_data("https://mirror.coggle.club/dataset/affairs.txt")print(data.iloc[int(row)])                           """</code></pre><img src="/2021/11/16/Linux-linux/3.png" style="zoom:80%;"><h4 id="7-在Linux系统中后台运行应用程序"><a href="#7-在Linux系统中后台运行应用程序" class="headerlink" title="7. 在Linux系统中后台运行应用程序"></a>7. 在Linux系统中后台运行应用程序</h4><p>步骤1：新建sleep.py文件，实现功能-1.程序一致运行，2. 每10秒输出当前时间</p><p>代码：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># sleep.py</span><span class="token keyword">import</span> time <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre><p>运行结果</p><p><img src="/2021/11/16/Linux-linux/sleep_py.png"></p><p>步骤2：学习 <code>&amp;</code> 和 <code>nohup</code> 后台执行方法</p><p>Linux系统管理-工作管理</p><p>工作管理方法：</p><ul><li><p><code>命令&amp;</code>：把命令放在后台，并在后台执行</p></li><li><p><code>ctrl + z</code>：按下 <code>ctrl + z</code>快捷键，放在后台暂停</p></li></ul><ol><li><p>打包命令</p><pre class=" language-shell"><code class="language-shell">tar czf affairs.tgz affairs    # c-打包，z-压缩格式.gz，f-文件名</code></pre></li><li><p><code>命令 &amp;</code>：把命令放在后台，并在后台执行，关闭窗口，进程仍然会在后台执行</p></li></ol><p>  正常命令</p><pre class=" language-shell"><code class="language-shell">ping -c 20 baidu.com > baidu.ping # 执行ping命令，发送20个数据包，并将结果保存到文件</code></pre><p>  如果 <code>ctrl + z</code> ，进程会放到后台并暂停，如下图</p><p>   <img src="/2021/11/16/Linux-linux/ctrl+z%EF%BC%88&%EF%BC%89%E4%BB%BB%E5%8A%A1%E6%9A%82%E5%81%9C.png"></p><p>  后台执行ping命令</p><pre class=" language-shell"><code class="language-shell">ping -c 20 baidu.com > baidu.ping &</code></pre><p>  <code>jobs命令</code>：显示所有后台的任务，参数：-l，显示工作的PID，需要说明的是，jobs用于显示Linux的任务列表以及任务状态，包括后台运行的任务，可以显示任务号及其对应的进程号，其中任务号是以普通用户的角度进行的，而进程号是从系统管理员的角度来看的，一个任务可以对应一个或者多个进程号</p><p>  <img src="/2021/11/16/Linux-linux/jobs%E6%98%BE%E7%A4%BA%E4%BB%BB%E5%8A%A1%E5%8F%B7.png"></p><p>  <code>+</code> 表示最近一个放入后台的工作，也是工作恢复时，默认恢复的工作，<code>-</code> 代表倒数第二个放入后台的工作</p><p>  恢复到前台执行：<code>fg %工作号</code>，将后台正在运行的进程或者后台暂停的进程恢复到前台运行状态，<code>%</code> 可以省略，工作号可以用 <code>+</code> 或 <code>-</code> 表示， 也可以不写， 默认是 <code>+</code> </p><p>  <img src="/2021/11/16/Linux-linux/fg%E5%B0%86%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E6%81%A2%E5%A4%8D%E5%88%B0%E5%89%8D%E5%8F%B0.png"></p><p>  将数据包的长度增加到80，然后进一步测试，当将后台运行的程序放到前台时候，<code>ctrl + z</code> 仍将程序挂起到后台</p><p>  <img src="/2021/11/16/Linux-linux/jobs%E4%B8%8Efg%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8.png"></p><p>  恢复到到后台执行：<code>bg %工作号</code>，将后台暂停的进程恢复到在后台运行，对已经在运行的程序不生效，后台恢复执行的命令是不能和前台有交互的，否则不能恢复到前台执行，停止的进程都会放到后台执行</p><p>  <img src="/2021/11/16/Linux-linux/jobs%E5%92%8Cbg%E9%85%8D%E5%90%88%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C.png"></p><p>  如果该进程已经在后台运行，则不会生效：</p><p>  <img src="/2021/11/16/Linux-linux/bg%E5%AF%B9%E4%BA%8E%E5%B7%B2%E7%BB%8F%E5%9C%A8%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E5%91%BD%E4%BB%A4%E4%B8%8D%E7%94%9F%E6%95%88.png"></p><ol start="3"><li><p>脱离终端</p><p> 命令放入后台执行，只能在当前登录的终端执行，一旦用户退出当前终端后台程序就会被终止，使后台进程脱离终端执行的方法：</p></li></ol><ul><li><p>第一种是需要后台执行的命令加入 <code>/etc/rc.local</code> 文件</p></li><li><p>第二种是使用系统定时任务，让系统在执行的时间执行某个后台命令</p></li><li><p>第三种是使用nohup命令，标准方法</p><p>  <code>nohup</code> 命令</p><p>  <code>nohup 命令 &amp;</code>：是命令脱离终端，在终端关闭后依然能够存在</p><pre class=" language-shell"><code class="language-shell">nohup ping -c 20 baidu.com > baidu.ping &</code></pre><p>  <a href="https://blog.csdn.net/twilight_karl/article/details/77857203">参考链接</a></p></li></ul><ol start="4"><li><p>采用 <code>(command &amp;)</code> ：会将ppid设置为1，而非当前会话的id，并且jobs查看不到当前的作业，<code>ctrl + d</code> 或者关闭窗口进程人仍然在后台运行</p><p> ![](./linux/(command + &amp;)关闭窗口，进程仍然能够运行.png)</p></li><li><p>采用 <code>setid command</code> ：会将ppid设置为1，而非当前会话的id，<code>ctrl + d</code> 或者关闭窗口进程仍然会在后台执行</p><p> <img src="/2021/11/16/Linux-linux/setsid%E5%85%B3%E9%97%AD%E7%AA%97%E5%8F%A3%E8%BF%9B%E7%A8%8B%E4%BB%8D%E8%83%BD%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C.png"></p><p> 其中 <code>setid</code>找不到命令，<code>setsid</code>可行</p></li><li><p>采用 <code>disown</code></p><p> 若是在命令前加上 <code>nohup</code> 或者 <code>setsid</code> 就能够避免 <code>HUP</code> 信号的影响，但是如果没有事先处理就已经提交命令该如何补救呢？<code>disown</code> 可以做到这一点</p><p> 使用 <code>disown -h jobspec</code> 使某个作业忽略 <code>HUP</code> 信号</p><p> 使用 <code>disown -ah</code> 使全部作业忽略 <code>HUP</code> 信号</p><p> 使用 <code>disown -rh</code> 使正在运行的作业忽略 <code>HUP</code> 信号</p><p> <img src="/2021/11/16/Linux-linux/disown%E8%A1%A5%E6%95%91%E5%BD%93%E5%89%8D%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E8%BF%9B%E7%A8%8B%E5%81%9C%E6%AD%A2%E7%9A%84%E6%96%B9%E6%B3%95.png"></p><p> 需要注意的是，当使用 <code>disown</code> 以后，会把目标作业从作业列表移除，所以不能通过 <code>jobs</code> 来查看，但是仍然可以通过 <code>ps -ef</code> 查找到它</p><p> <img src="/2021/11/16/Linux-linux/disown%E4%BC%9A%E5%B0%86%E4%BB%BB%E5%8A%A1%E4%BB%8Ejob%E4%B8%AD%E7%A7%BB%E9%99%A4%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87jobs%E6%9F%A5%E7%9C%8B%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87ps-ef%E6%9F%A5%E7%9C%8B.png"></p></li><li><p>采用 <code>screen</code>：多用于多重视窗管理程序 </p><p> 用 <code>screen -dmS session name</code> 建立一个处于断开模式下的会话</p><p> 用 <code>screen -list</code> 列出所有会话</p><p> 用 <code>screen -r session name</code> 重新连接指定会话</p><p> 用 <code>screen -x session name(id)</code> 连接 attached 会话</p><p> 用 <code>ctrl + a  d</code> 暂时断开当前会话，不可以直接 <code>ctrl + d</code> 这样会 ternimate screen </p><p> 使用指定coggle服务器出现问题： <code>getpwuid() can&#39;t identify your account!</code>， 可能是权限问题</p></li></ol><p><img src="/2021/11/16/Linux-linux/screen%E5%88%9B%E5%BB%BA%E5%A4%9A%E9%87%8D%E8%A7%86%E7%AA%97%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F.png"></p><p>​    使用自己的服务器测试创建一个断开模式下的会话，列出所有会话，重新连接指定会话，查看所有会话</p><p><img src="/2021/11/16/Linux-linux/screen%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E4%BC%9A%E8%AF%9D.png"></p><p>​    退出会话，连接attached会话时</p><p><img src="/2021/11/16/Linux-linux/screen-x%E9%87%8D%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BC%9A%E8%AF%9D.png"></p><p>​    连接上之后：</p><p><img src="/2021/11/16/Linux-linux/screen-x%E8%BF%9E%E6%8E%A5%E4%BC%9A%E8%AF%9D%E5%90%8E%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BC%9A%E8%AF%9D.png"></p><p>​    可以断开当前会话</p><p>​    <code>kill screen session </code>: </p><pre class=" language-shell"><code class="language-shell">screen -S pid -X quit</code></pre><p><img src="/2021/11/16/Linux-linux/screen-s-pid-x-quit%E6%96%AD%E5%BC%80%E6%89%80%E6%9C%89%E4%BC%9A%E8%AF%9D.png"></p><p>参考：<a href="https://blog.csdn.net/a736933735/article/details/89577557">https://blog.csdn.net/a736933735/article/details/89577557</a></p><p>​          <a href="http://ipcmen.com/jobs">http://ipcmen.com/jobs</a></p><p>​          <a href="http://www.noobyard.com/article/p-epbhljss-ka.html">http://www.noobyard.com/article/p-epbhljss-ka.html</a></p><p>​          <a href="https://blog.csdn.net/twilight_karl/article/details/77857203">https://blog.csdn.net/twilight_karl/article/details/77857203</a></p><p>​          <a href="https://blog.csdn.net/saife/article/details/78276014">https://blog.csdn.net/saife/article/details/78276014</a></p><p>步骤3：学习 <code>tmux</code> 的使用，将步骤1的程序进行后台运行，并将输出结果写入到txt文件。</p><p>​    <code>Tmux</code> 是一个终端复用器</p><ol><li><p>会话与进程</p><p>用户与计算机的临时交互就叫做一次会话（session）</p><p>会话一个重要的特点是，窗口与其中启动的进程是连在一起的，打开窗口，会话开始，关闭窗口，会话结束，ssh登录远程计算机，打开远程窗口执行命令，断开再次连接，找不到上次执行的命令，因为上次的ssh会话已经终止，里面的进程也随之消失，为了解决这个问题，要将会话与窗口解绑</p></li><li><p><code>Tmux</code> 的作用</p><p> 会话与窗口的解绑工具</p><ul><li>允许在单个窗口中访问多个会话，对于运行多个命令行程序很有用</li><li>允许让新窗口接入已经存在的会话</li><li>允许每个会话有多个连接窗口，因此可以多人实时共享会话</li><li>支持窗口任意的垂直和水平拆分</li></ul></li><li><p>启动与退出</p><pre class=" language-shell"><code class="language-shell">tmux  # 启动</code></pre> <img src="/2021/11/16/Linux-linux/tmux启动.png" style="zoom:50%;"><pre class=" language-shell"><code class="language-shell">exit # 或者ctrl+d，退出</code></pre><p> 前缀键，所有的快捷键都需要前馈键唤起，默认的前馈键是<code>ctrl + b</code>， 按下<code>?</code> 显示帮助信息，按下<code>ESC</code> 或 <code>q</code> 键，退出帮助</p></li><li><p>会话管理</p><p> 新建会话</p><pre class=" language-shell"><code class="language-shell">tmux new -s <session-name></code></pre><p> 分离会话</p><pre class=" language-shell"><code class="language-shell">tmux detach # 或者ctrl+b d，实现当前会话与窗口分离</code></pre><p> <img src="/2021/11/16/Linux-linux/tmux-detach%E5%88%86%E7%A6%BB%E4%BC%9A%E8%AF%9D.png"></p><pre class=" language-shell"><code class="language-shell">tmux ls # or tmux list-session</code></pre><p> <img src="/2021/11/16/Linux-linux/tmux%E6%98%BE%E7%A4%BA%E4%BC%9A%E8%AF%9D%E5%88%97%E8%A1%A8.png"></p><p> 接入会话</p><pre class=" language-shell"><code class="language-shell">tmux attach -t 0 # 使用会话编号tmux attach -t <session-name> # 使用会话名称</code></pre><p> 杀死会话</p><pre class=" language-shell"><code class="language-shell">tmux kill-session -t 0  # 会话编号tmux kill-session -t <session-name> # 会话名</code></pre><p> 切换会话</p><pre class=" language-shell"><code class="language-shell">tmux switch -t 0 # 会话编号tmux switch -t <session-name> # 会话名</code></pre><p> 重命名会话</p><pre class=" language-shell"><code class="language-shell">tmux rename-session -t 0 <new-name> # 将0号会话重命名</code></pre><p> 会话快捷键</p><ul><li><p><code>ctrl + b d</code>：<strong>分离当前会话</strong>，这一点很重要，不能直接退出，直接退出会导致会话关闭</p></li><li><p><code>ctrl + b d</code>：列出所有会话</p></li><li><p><code>ctrl +ｂ＄</code>：重命名当前会话</p></li></ul><p> 最简单操作流程</p><pre class=" language-shell"><code class="language-shell">1. 新建会话 tmux new -s <session-name>2. 在Tmux窗口中运行所需要的程序3. 按下ctrl+b d将会话分离4.下次使用时，重新连接到会话，tmux attach-session -t <session-name></code></pre></li><li><p>窗口操作</p></li><li></li></ol><p>参考链接：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p><p>实现任务：将步骤1的程序进行后台运行，并将输出结果写入到txt文件中</p><p>​     sleep.py</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> sysf <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"sleep.txt"</span><span class="token punctuation">,</span> <span class="token string">"w+"</span><span class="token punctuation">)</span>sys<span class="token punctuation">.</span>stdout<span class="token operator">=</span>f<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""print time every 10 seconds"""</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre><p><img src="/2021/11/16/Linux-linux/python3-sleep-&%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C.png"></p><p>只有程序运行结束才能看见sleep.py文件有内容</p><p><img src="/2021/11/16/Linux-linux/%E7%AE%80%E5%8D%95ctrl_c%E7%BB%88%E6%AD%A2%E5%89%8D%E5%8F%B0%E5%91%BD%E4%BB%A4%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E8%BE%93%E5%87%BA.png"></p><p>进行重定向也是可以的，进行 <code>ctrl+c</code>停止代码运行可以看见写入的结果：</p><pre class=" language-shell"><code class="language-shell">import timewhile(1):    """print time every 10 seconds"""    print(time.ctime())    time.sleep(10)</code></pre><p><img src="/2021/11/16/Linux-linux/%E4%BD%BF%E7%94%A8%E9%87%8D%E5%AE%9A%E5%90%91%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA.png"></p><p>实现功能</p><p><img src="/2021/11/16/Linux-linux/nohup&%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C.png"></p><p>可以看到退出了窗口和连接，<code>ps -ef </code> 可以看见程序在运行</p><p><img src="/2021/11/16/Linux-linux/ps-ef%E6%9F%A5%E7%9C%8Bpython3-sleep%E4%BB%BB%E5%8A%A1%E8%BF%9B%E7%A8%8B.png"></p><p>但是文件中看不到输出，是个问题</p><p><img src="/2021/11/16/Linux-linux/%E9%97%AE%E9%A2%98%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E8%BE%93%E5%87%BA.png"></p><p>最后发现是输出的缓存区导致了txt文件中没有内容</p><pre class=" language-shell"><code class="language-shell">nohup python3 -u sleep.py  >＞ sleep.txt & </code></pre><p>然后再查看文件就有相应的输出</p><p><img src="/2021/11/16/Linux-linux/python3-u%E8%BE%93%E5%87%BA%E4%B8%8D%E8%BF%9B%E5%85%A5%E7%BC%93%E5%AD%98%E5%8C%BA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98.png"></p><p>但是直接通过nohup可以实现在后台运行，断开ssh再次连接也是没有问题的，但是jobs命令便查找不到</p><p>因此借助于tmux创建一个会话，这样再次登录只需进入会话就可以了</p><p>进行测试：</p><img src="/2021/11/16/Linux-linux/结合tmux进行会话任务保留测试.png" style="zoom:50%;"><p><code>ctrl+b d</code> 脱离会话</p><p>再此登录，仍然能够看见</p><img src="/2021/11/16/Linux-linux/tmux再此登录ssh然后进入会话仍然看见jobs任务.png" style="zoom:50%;"><p>参考链接：<a href="https://www.jianshu.com/p/9c5c9d36eb31">https://www.jianshu.com/p/9c5c9d36eb31</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
